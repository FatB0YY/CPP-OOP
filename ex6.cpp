#include <iostream>
#include <vector>
#include <string>
#include <exception>

// C++
struct Figure {
	Figure() {
		// не virtual
		draw();
	}

	virtual void draw() const {
		// drawing
	}

	// абстрактный класс
	virtual void draw() = 0;

	~Figure() {

	}
};

struct Circle : Figure {
	Circle() {

	}

	 void draw() const override{
		// drawing
	}

	 ~Circle() {

	 }
};

struct Square : Figure{
	 void draw() const override {
		// drawing
	}
};

int main() {
	std::vector<Figure*> figures{ new Circle{}, new Square {} };
	for (const Figure* f : figures) {
		f->draw();
		delete f;
	}

	// срезка, так писать нельзя
	Figure f = Circle{};

	// а так можно
	Circle c;
	Figure& f = c;
	Figure* f = &c;
	Figure* f = new Circle;

	return EXIT_SUCCESS;
}

/*
	Полиморфизм. И так у нас есть цикл. Мы хотим объект, абстрактный, те мы не хотим четко зависеть какой у нас внутри вектор получается объект. 
	То ли это круг, то ли квадрат. Мы просто хотим иметь абстрактный объект фигур, массив, лист, список, не важно, и просто хотим их нарисовать. 
	Вызывать метод drow. Но мы хотим их рисовать так, как будто каждая фигура рисовала себя сама, самостоятельно. Для этого используем virtual drow. 

	Те когда мы будем проходиться по вектору,  будет вызываться не базовый класс, а будет вызываться сперва Circle, а после Square. 
	Те фигура будет сама себя рисовать. 
	Она будет рисовать через УКАЗАТЕЛЬ на базовый класс.

	Например мы прилетели в сочи и нам нужно заказать такси, вот заказ автомобиля это как будто вектор фигур, 
	мы не знаем какой именно автомобиль приедет, потом нам предлагают конкретную машину и это уже реализация. 
	Это абстракция, прокат машин. Те этот метод не перекроет значения, а переопределит. Если метод не будет определен, 
	то вызовется базовый метод с таким именем. Если не напишем const, то вызовется базовый класс, тк метод не будет перегружен.

	Вызов виртуальной ф-ции в конструкторе или деструкторе. Если вызывать виртуальную ф-цию в констр ил дестр, 
	можно иметь ввиду, как будто слово virtual там не работает. Virtual не работает.

	Абстрактность. Мы можем написать virtual void draw() = 0;, это говорит то, что этот класс теперь является абстрактным. (Figure). 
	Это класс, который имеет хотя бы одну чисто виртуальную функцию. У абстрактных классов нет инстансов, то есть мы не можем Figure figure1 – error.

	Срезка. У базового класса есть какая-то определённая часть и у производного класса есть определённая часть. 
	Производного часть содержит как и базовую часть, так и производную часть. В данном случае мы берем и просто обрезаем производную часть.

	также есть таблица виртуальных функций.

	Виртуальный деструктор нужно писать только в том случае, если мы собираемся использовать полиморфизм. Тк мы собираемся работать с объектом через ссылку, либо через указатель на базовый класс.
*/