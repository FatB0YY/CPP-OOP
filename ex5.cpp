#include <iostream>
#include <vector>
#include <string>
#include <exception>

// C++
struct Data {
	Data() : m_data(new int{}) {}
	~Data() {
		delete m_data;
	}

	// correct
	Data(const Data& other) : m_data(new int{*other.m_data}) {

	}

	Data& operator = (const Data& other) {
		if (this != &other) {
			delete m_data;
			m_data(new int{ *other.m_data });
		}
		return *this;
	}
public:
	int* m_data;
};

int main() {
	Data data1;
	// data1 = data1;
	Data data2 = data1;

	

	return EXIT_SUCCESS;
}


/*
	При копировании, скопируется сам указатель. 
	Теперь указатель на data1 и data2 указывают на один и тот же блок памяти внутри хипа. 
	Соответственно когда будет удаляться data2, вызовется delete для этого блока и data1 будет удаляться и вызовется повторный delete. 
	Double delete = undefined behaviour. 


	В C++ появились конструкторы и операторы копирования. Они решают эту проблему.
	Теперь мы не просто копируем указатель, мы копируем значения этих указателей. 
	Теперь два указателя будут показывать на разные блоки памяти.


	Правило 3. Как только нам нужно написать что то одно (либо конструктор копирования, либо оператор копирования, либо деструктор), то значит, 
	что нам нужно реализовать все остальное, те мы как то будем управлять нашими ресурсами (это называется правило 3х, актуально до c++ 11, 
	потом правило 5 и семантика, те добавляется конструктор перемещения и оператор перемещения).


	Правило нуля. Если мы используем класс, который внутри себя уже реализовывает правило 3 или 5, то мы не будем писать ничего, все будет корректно работать. 
	Нужно пытаться это использовать.
*/

